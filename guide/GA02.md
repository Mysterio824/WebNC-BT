Okay, here is the `GA2.md` file, incorporating the requirements and following the structure of your `GA1.md` example. It covers both the `Film` and `Actor` APIs, includes instructions for Swagger UI, and explains how the requirements were met.

````markdown
# Sakila Film & Actor API

This is a RESTful API built with Spring Boot to perform CRUD (Create, Read, Update, Delete) operations on the `film` and `actor` tables (and related entities) from the Sakila database sample.

## Tech Stack

* **Java 21** (or 17+)
* **Spring Boot 3**
* **Spring Data JPA** (Hibernate)
* **Spring Validation** (Handles client parameter validation via annotations)
* **Maven**
* **MySQL 8**
* **Docker & Docker Compose**
* **Springdoc OpenAPI (Swagger UI)** (Provides RESTful API documentation and testing UI)

-----

## Prerequisites

Before you begin, ensure you have the following software installed on your machine:

* **JDK 17 or higher**: [Download OpenJDK](https://adoptium.net/)
* **Apache Maven**: [Download Maven](https://maven.apache.org/download.cgi)
* **Docker & Docker Compose**: [Download Docker](https://www.docker.com/products/docker-desktop/)
* **An API Client (Optional)**: [Postman](https://www.postman.com/downloads/) or `curl` (available on macOS/Linux). Swagger UI (included) can also be used.

-----

## How to Run the Project

Follow these steps to get the database and the application running.

### Step 1: Clone the Repository (If not already done)

```bash
# Replace with your repository URL if different
git clone [https://github.com/Mysterio824/WebNC-BT.git](https://github.com/Mysterio824/WebNC-BT.git)
cd WebNC-BT
````

### Step 2: Ensure Required Files are Present

This guide assumes the following files are in the root of your project directory:

```
.
├── docker-compose.yml  <-- For running the database
├── sakila-mysql.sql    <-- The database initialization script
├── pom.xml             <-- The project's dependencies
└── src/                <-- The application source code
```

### Step 3: Start the MySQL Database with Docker

We will use Docker Compose to start a MySQL container that is pre-configured and initialized with your `sakila-mysql.sql` file.

1.  Open a terminal in the project's root directory.

2.  Run the following command:

    ```bash
    docker-compose up -d
    ```

    * `-d` means "detached mode," so it runs in the background.

3.  This command will:

    * Pull the `mysql:8.0` image (if not already present).
    * Start the container named `webnc-mysql`.
    * Expose the database on your machine's port **3307**.
    * Create a database named `webnc_db`.
    * **Crucially**: It will automatically run the `sakila-mysql.sql` script inside the container to create and populate all necessary Sakila tables.

4.  You can verify the database is running with `docker-compose ps`:

    ```
    NAME          COMMAND                  SERVICE       STATUS        PORTS
    webnc-mysql   "docker-entrypoint.s…"   webnc-mysql   running (healthy)   0.0.0.0:3307->3306/tcp
    ```

**Note:** The SQL initialization only runs the *first time* the container volume is created. If you modify `sakila-mysql.sql` or need to reset the database completely, you must first destroy the container and its associated data volume:

```bash
docker-compose down -v
```

Then run `docker-compose up -d` again to recreate everything from scratch.

### Step 4: Check Your Application Configuration

Your Spring Boot application is already configured in `src/main/resources/application.yml` to connect to this Dockerized database:

```yaml
server:
  port: 8888  # The application will run on this port

spring:
  application:
    name: bt
  datasource:
    url: jdbc:mysql://localhost:3307/webnc_db # Connects to the Docker DB on port 3307
    username: root
    password: root                          # Matches docker-compose.yml
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: none # Important: Use 'none' or 'validate' as the DB is created by the script
    show-sql: true
```

### Step 5: Run the Spring Boot Application

With the database running, you can now start the API server.

1.  In your terminal (in the project root directory), run the application using the Maven wrapper:

    ```bash
    # On macOS/Linux
    ./mvnw spring-boot:run

    # On Windows
    ./mvnw.cmd spring-boot:run
    ```

    *(Alternatively, if Maven is installed globally: `mvn spring-boot:run`)*

2.  Wait for the logs. Successful startup will show lines similar to:

    ```
    ... Tomcat started on port(s): 8888 (http) with context path ''
    ... Started BtApplication in ... seconds
    ```

Your API is now running on `http://localhost:8888`.

-----

## API Documentation and Testing (Swagger UI)

This project uses **Springdoc OpenAPI** to automatically generate interactive API documentation based on your controller code and annotations. This fulfills the requirement for RESTful API documentation and a UI tester.

### Accessing Swagger UI

1.  Open your web browser.
2.  Navigate to: **`http://localhost:8888/swagger-ui.html`**

### How Swagger UI Meets Requirements:

* **API Description:** Each endpoint (`/api/films`, `/api/actors/{id}`, etc.) is listed with its HTTP method (GET, POST, PUT, DELETE) and a summary/description provided by the `@Operation` annotations in the controllers.
* **Parameter Description:** Parameters (path variables like `{id}`, request bodies) are detailed, including whether they are required, their data type, and examples (provided via `@Parameter` annotations). Validation rules (like `@NotBlank`) are often reflected in the schema.
* **UI for Testing:** Swagger UI provides a "Try it out" button for each endpoint. You can fill in parameters, provide JSON request bodies, and click "Execute" to send a live request to your running API and see the response directly in the browser. This acts similarly to Postman.
* **Sample Data:**
    * **Request:** The "Schema" tab for request bodies shows the expected JSON structure. When using "Try it out", it often provides a template JSON you can modify.
    * **Response:** The "Responses" section details possible HTTP status codes (200, 201, 404, etc.). For successful responses, the "Schema" tab shows the structure of the response JSON (`AppApiResponse` wrapping `FilmResponse` or `ActorResponse`). Example values are often included.

-----

## API Endpoints (Testing with cURL)

Alternatively, you can test the API using `curl` commands in a **new terminal window**.

*(Tip: Pipe commands to `| jq` for pretty JSON output if you have `jq` installed).*

### Film API (`/api/films`)

#### 1\. Get all films

* **Endpoint**: `GET /api/films`

<!-- end list -->

```bash
curl -X GET http://localhost:8888/api/films | jq
```

#### 2\. Get film detail by ID

* **Endpoint**: `GET /api/films/{id}` (Example: ID 1)

<!-- end list -->

```bash
curl -X GET http://localhost:8888/api/films/1 | jq
```

#### 3\. Add new film

* **Endpoint**: `POST /api/films`
* *(Requires existing `languageId` like 1)*

<!-- end list -->

```bash
curl -X POST http://localhost:8888/api/films \
-H "Content-Type: application/json" \
-d '{
  "title": "New Test Movie",
  "description": "A great movie description.",
  "releaseYear": 2025,
  "languageId": 1,
  "rentalDuration": 5,
  "rentalRate": 3.99,
  "replacementCost": 20.99,
  "rating": "PG"
}' | jq
```

#### 4\. Update film

* **Endpoint**: `PUT /api/films/{id}` (Example: ID 1)

<!-- end list -->

```bash
curl -X PUT http://localhost:8888/api/films/1 \
-H "Content-Type: application/json" \
-d '{
  "title": "Updated Movie Title",
  "description": "An updated description.",
  "languageId": 1,
  "rating": "PG_13"
}' | jq
```

#### 5\. Delete film

* **Endpoint**: `DELETE /api/films/{id}` (Example: ID 1001 or another ID unlikely to cause constraint errors initially)
* *(Note: Deletion might fail due to foreign key constraints if the film is referenced in `inventory`, etc. Use soft delete or handle cascade/clearing in service logic for robust deletion).*

<!-- end list -->

```bash
# Try deleting a film that likely has no rentals/inventory first
curl -X DELETE http://localhost:8888/api/films/1001 | jq
```

### Actor API (`/api/actors`)

#### 6\. Get all actors

* **Endpoint**: `GET /api/actors`

<!-- end list -->

```bash
curl -X GET http://localhost:8888/api/actors | jq
```

#### 7\. Get actor detail by ID

* **Endpoint**: `GET /api/actors/{id}` (Example: ID 5)

<!-- end list -->

```bash
curl -X GET http://localhost:8888/api/actors/5 | jq
```

#### 8\. Add new actor

* **Endpoint**: `POST /api/actors`

<!-- end list -->

```bash
curl -X POST http://localhost:8888/api/actors \
-H "Content-Type: application/json" \
-d '{
    "firstName": "TEST",
    "lastName": "ACTOR"
}' | jq
```

#### 9\. Update an actor

* **Endpoint**: `PUT /api/actors/{id}` (Example: ID 5)

<!-- end list -->

```bash
curl -X PUT http://localhost:8888/api/actors/5 \
-H "Content-Type: application/json" \
-d '{
    "firstName": "JOHNNY (MODIFIED)",
    "lastName": "LOLLOBRIGIDA"
}' | jq
```

#### 10\. Delete an actor

* **Endpoint**: `DELETE /api/actors/{id}` (Example: ID 201 or the ID returned from the POST step)
* *(Note: Deletion might fail if the actor is linked to films in `film_actor`).*

<!-- end list -->

```bash
curl -X DELETE http://localhost:8888/api/actors/201 | jq
```

-----

## Validation

Client parameter validation (number of fields, datatype, field value) is handled using standard Spring Boot mechanisms:

* **`@Valid` Annotation:** Applied to `@RequestBody` parameters in the controllers triggers validation.
* **Constraint Annotations:** Annotations like `@NotBlank`, `@NotNull`, `@Min`, `@DecimalMin`, `@PositiveOrZero` are used within the `FilmRequest` and `ActorRequest` DTOs to define rules for each field.
* **Automatic Error Handling:** If validation fails, Spring Boot automatically returns a `400 Bad Request` response, typically handled by a global exception handler (not shown here, but standard practice) to provide informative error messages.

This setup ensures that incoming requests meet the required criteria before hitting the service layer.

```
```