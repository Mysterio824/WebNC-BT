You're right, using a real API endpoint like `FilmController` makes for a much better and more practical testing example.

Here is the updated `GA04.md` guide. It's structured like your `GA1.md` example but focuses on the OAuth2/JWT flow and uses your `FilmController` for the testing steps, as you requested. I've also followed your instruction to focus on the setup and testing rather than detailing all the implementation code.

-----

# API Security with Google OAuth2 and Internal JWTs

This guide details an API security model for a Spring Boot application. The system uses **Google as an external Identity Provider** to authenticate users via OAuth2. Once Google verifies the user's identity, our backend issues its **own internal, stateless JWT (signed with HMAC512)**.

This internal JWTâ€”not the Google tokenâ€”is then used to secure all subsequent requests to our API.

## What This Guide Covers

This implementation addresses several core security concepts:

* **ðŸ‘‰ 1. External User Authentication:** We use Google's OAuth2 "Authorization Code" flow to securely verify a user's identity without ever handling their password.
* **ðŸ‘‰ 2. Internal Token Issuance:** After a successful Google login, our `AuthService` and `JwtTokenProvider` work together to generate a custom, HS512-signed JWT. This token contains the user's profile claims (email, name, etc.).
* **ðŸ‘‰ 3. Secure API Endpoints:** We protect specific API routes (e.g., `/api/films/**`) using Spring Security.
* **ðŸ‘‰ 4. Stateless Token Validation:** We configure Spring Security as an `oauth2-resource-server` to validate our *internal* JWT on every protected request, ensuring all API calls are authenticated.

## Tech Stack

* **Spring Boot 3**: The application backend.
* **Spring Security 6**: Used to configure the `oauth2-resource-server` and `JwtDecoder`.
* **Google OAuth2**: The external Identity Provider (Authorization Server).
* **Java JWT (`jjwt`)**: A Java library to create and sign our internal JWTs.
* **RestTemplate**: Used by `OauthClient` for server-to-server communication with Google.

-----

## Project File Structure

To implement this, your project should include the following key files:

```
.
â””â”€â”€ src/
    â””â”€â”€ main/
        â”œâ”€â”€ java/
        â”‚   â””â”€â”€ com/webnc/bt/
        â”‚       â”œâ”€â”€ config/
        â”‚       â”‚   â””â”€â”€ SecurityConfig.java       <-- (REQUIRED: Configures JWT validation)
        â”‚       â”œâ”€â”€ controller/
        â”‚       â”‚   â”œâ”€â”€ AuthController.java       <-- (The public login endpoint)
        â”‚       â”‚   â””â”€â”€ FilmController.java       <-- (The protected API endpoint)
        â”‚       â”œâ”€â”€ dto/
        â”‚       â”‚   â””â”€â”€ response/
        â”‚       â”‚       â”œâ”€â”€ GoogleTokenResponse.java
        â”‚       â”‚       â””â”€â”€ ProfileResponse.java
        â”‚       â”œâ”€â”€ repository/
        â”‚       â”‚   â””â”€â”€ httpclient/
        â”‚       â”‚       â””â”€â”€ OauthClient.java
        â”‚       â””â”€â”€ service/
        â”‚           â”œâ”€â”€ AuthService.java
        â”‚           â””â”€â”€ JwtTokenProvider.java
        â””â”€â”€ resources/
            â”œâ”€â”€ application.properties
            â””â”€â”€ .env (optional)             <-- (Holds your secret keys)
```

-----

## How to Set Up and Run

This setup involves configuring Google, your Spring Boot app, and Spring Security.

### Step 1: Get Google OAuth2 Credentials

1.  Go to the [Google Cloud Console](https://console.cloud.google.com/apis/credentials).
2.  Create a new project or select an existing one.
3.  Go to **Credentials** \> **Create Credentials** \> **OAuth client ID**.
4.  Select **Web application**.
5.  Under **Authorized redirect URIs**, add the URI your backend will listen on. For this demo, add:
    * `http://localhost:8888/grantcode`
6.  Click **Create**. Copy your **Client ID** and **Client Secret**.

### Step 2: Configure Spring Boot (`.env` & `application.properties`)

**A. Create a `.env` file**
Create a file named `.env` in your project's root directory to hold your secrets.

**`.env`**

```ini
# --- Google Credentials ---
CLIENT_ID=YOUR_GOOGLE_CLIENT_ID_HERE
CLIENT_SECRET=YOUR_GOOGLE_CLIENT_SECRET_HERE

# --- Internal JWT Secret ---
# Generate a strong, 64-byte Base64 key for HS512
JWT_SECRET=YmFzZTY0LXNlY3JldC1rZXktZm9yLWhhY3NoNTYtYWxnb3JpdGhtLW5lZWRzLXRvLWJlLXN0cm9uZy1hbmQtLWxvbmctaW5zZWN1cmU=
```

**B. `application.properties`**
Your properties file will read these values from the `.env` file.

```properties
server:
  port: 8888

spring:
  config:
    import: optional:file:.env[.properties]
  application:
    name: bt

# ... your database config ...

# === OAuth2 Config ===
oauth2:
  google:
    client-id: ${CLIENT_ID}
    client-secret: ${CLIENT_SECRET}

# === Internal JWT Config ===
jwt:
  secret:
    key: ${JWT_SECRET}
  expiration:
    ms: 3600000 # 1 hour
```

### Step 3: Add Maven Dependencies (`pom.xml`)

You must add the `oauth2-resource-server` and `jjwt` libraries.

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>

    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.12.5</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.12.5</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.12.5</version>
        <scope>runtime</scope>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

### Step 4: Implement Core Logic

Your implementation code (which you've provided) handles the logic:

* **DTOs:** `GoogleTokenResponse` and `ProfileResponse` are DTOs to map JSON responses from Google.
* **`OauthClient.java`:** This client uses `RestTemplate` to call Google's `/token` and `/userinfo` endpoints.
* **`JwtTokenProvider.java`:** This service uses your `JWT_SECRET` to create a new HS512-signed JWT.
* **`AuthService.java`:** This service orchestrates the flow: it uses the `OauthClient` to get the user's profile and then uses `JwtTokenProvider` to issue your internal token.

### Step 5: Configure Spring Security (The "Validation" Part)

This is the most critical piece. This class tells Spring Security to:

1.  Make `/auth/**` and `/grantcode` public.
2.  Secure *all other* requests (e.g., `/api/**`).
3.  Validate any `Bearer` token against our `jwt.secret.key` using the **HS512** algorithm.

**`com/webnc/bt/config/SecurityConfig.java`**

```java
package com.webnc.bt.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.web.SecurityFilterChain;

import javax.crypto.spec.SecretKeySpec;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Value("${jwt.secret.key}")
    private String jwtSecretKey;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                // 1. Permit the OAuth2 redirect and our token endpoint
                .requestMatchers("/grantcode").permitAll()
                .requestMatchers("/auth/**").permitAll()
                // 2. Secure all other requests
                .anyRequest().authenticated()
            )
            // 3. Configure as a Resource Server that validates our internal JWT
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));

        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        // 1. Decode the Base64-encoded key
        byte[] keyBytes = java.util.Base64.getDecoder().decode(jwtSecretKey);
        
        // 2. Create the SecretKeySpec for HMAC
        SecretKeySpec secretKey = new SecretKeySpec(keyBytes, "HmacSHA512");

        // 3. Build the decoder, specifying the HS512 algorithm
        return NimbusJwtDecoder.withSecretKey(secretKey)
                .macAlgorithm(MacAlgorithm.HS512)
                .build();
    }
}
```

### Step 6: Create API Endpoints

Your `FilmController` is automatically secured because it's under `/api/**`. You also need a public `AuthController` (or similar) to handle the `/grantcode` redirect.

### Step 7: Run the System

1.  Make sure your `.env` file is filled out.
2.  Run the Spring Boot application:
    ```bash
    ./mvnw spring-boot:run
    ```

-----

## How to Use and Test the System

Follow this exact flow to test the entire implementation.

### ðŸ‘‰ 1. Get the Google Authorization Code (Req 1)

You cannot use `curl` for this step. You **must** do this in a web browser.

1.  Construct the following URL. Replace `YOUR_CLIENT_ID_HERE` with your actual Google Client ID from the `.env` file.

    ```
    https://accounts.google.com/o/oauth2/v2/auth?client_id=YOUR_CLIENT_ID_HERE&redirect_uri=http://localhost:8888/grantcode&response_type=code&scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile%20https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email%20openid&prompt=consent&access_type=offline
    ```

2.  Paste this URL into your browser.

3.  Log in to your Google account.

4.  After you approve, Google will redirect you back to your Spring Boot app's endpoint: `http://localhost:8888/grantcode?code=...`

5.  Your browser will display the JSON response from your `AuthController`.

    **Example Response (in browser):**

    ```json
    {
      "app_token": "eyJhbGciOiJIUSHS..." // This is your new, internal JWT
    }
    ```

6.  **Copy this `app_token` value.**

### ðŸ‘‰ 2. Test the Secured Endpoint (Req 3 & 4)

Now we will use `curl` (or Postman) to act like a mobile or web app, using the `app_token` we just received.

**Test A: Access without a Token (Should Fail)**
This test proves our `FilmController` is secure.

```bash
curl -v http://localhost:8888/api/films

# --- EXPECTED RESPONSE ---
# < HTTP/1.1 401 Unauthorized
# < WWW-Authenticate: Bearer
```

**Test B: Access with the Internal Token (Should Succeed)**
This test proves our `JwtDecoder` and `SecurityConfig` are working for `GET` requests.

1.  Set a shell variable with the token you copied from the browser.

    ```bash
    # (Make sure to paste your actual token here)
    export TOKEN="eyJhbGciOiJIUSHS..."
    ```

2.  Make the request with the `Authorization: Bearer` header.

    ```bash
    curl -H "Authorization: Bearer $TOKEN" http://localhost:8888/api/films

    # --- EXPECTED RESPONSE ---
    # HTTP/1.1 200 OK
    # {
    #   "message": "Films retrieved successfully",
    #   "code": 200,
    #   "result": [
    #     { "filmId": 1, "title": "ACADEMY DINOSAUR", ... },
    #     { "filmId": 2, "title": "ACE GOLDFINGER", ... }
    #   ]
    # }
    ```

**Test C: Access a Mutating Endpoint (Should Succeed)**
This proves that `POST`, `PUT`, etc. are also protected and work correctly.

```bash
curl -X POST http://localhost:8888/api/films \
     -H "Authorization: Bearer $TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
           "title": "NEW TEST FILM",
           "description": "A film about testing.",
           "releaseYear": 2025,
           "languageId": 1,
           "rentalDuration": 3,
           "rentalRate": 4.99,
           "length": 120,
           "replacementCost": 19.99,
           "rating": "PG-13",
           "specialFeatures": "Trailers,Commentaries"
         }'

# --- EXPECTED RESPONSE ---
# HTTP/1.1 201 Created
# {
#   "message": "Film created successfully",
#   "code": 200,
#   "result": { "filmId": 1001, "title": "NEW TEST FILM", ... }
# }
```

**Test D: Access with Google's Token (Should Fail)**
This is an important test. If you check your Spring Boot logs, you can find the *Google* access token (variable `accessToken` in `AuthService`). Try using *that* token to access your API.

```bash
# This is the Google token, NOT your internal one
export GOOGLE_TOKEN="ya29.A0ATi6K2tLPv..."

curl -v -H "Authorization: Bearer $GOOGLE_TOKEN" http://localhost:8888/api/films

# --- EXPECTED RESPONSE ---
# < HTTP/1.1 401 Unauthorized
# < WWW-Authenticate: Bearer error="invalid_token", error_description="..."
```

This fails (as intended) because your server is configured to validate tokens signed with *your* `jwt.secret.key`, not tokens signed by Google. This successfully decouples your API's security from the external identity provider.

Ref: https://freedium.cfd/https://medium.com/@sallu-salman/implementing-sign-in-with-google-in-spring-boot-application-5f05a34905a8