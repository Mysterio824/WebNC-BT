# Sakila Actor API

This is a simple RESTful API built with Spring Boot to perform CRUD (Create, Read, Update, Delete) operations on the `actor` table from the Sakila database.

## Tech Stack

* **Java 21** (or 17+)
* **Spring Boot 3**
* **Spring Data JPA** (Hibernate)
* **Maven**
* **MySQL 8**
* **Docker & Docker Compose**

-----

## Prerequisites

Before you begin, ensure you have the following software installed on your machine:

* **JDK 17 or higher**: [Download OpenJDK](https://adoptium.net/)
* **Apache Maven**: [Download Maven](https://maven.apache.org/download.cgi)
* **Docker & Docker Compose**: [Download Docker](https://www.docker.com/products/docker-desktop/)
* **An API Client**: [Postman](https://www.postman.com/downloads/) or `curl` (available on macOS/Linux).

-----

## How to Run the Project

Follow these steps to get the database and the application running.

### Step 1: Clone the Repository (If not already done)

```bash
# Replace with your repository URL
git clone https://github.com/Mysterio824/WebNC-BT.git
cd WebNC-BT
```

### Step 2: Ensure Required Files are Present

This guide assumes the following files are in the root of your project directory:

```
.
├── docker-compose.yml  <-- For running the database
├── sakila-mysql.sql    <-- The database initialization script
├── pom.xml             <-- The project's dependencies
└── src/                <-- The application source code
```

### Step 3: Start the MySQL Database with Docker

This is the most important step. We will use Docker Compose to start a MySQL container that is pre-configured and initialized with your `sakila-mysql.sql` file.

1.  Open a terminal in the project's root directory.

2.  Run the following command:

    ```bash
    docker-compose up -d
    ```

    * `-d` means "detached mode," so it runs in the background.

3.  This command will:

    * Pull the `mysql:8.0` image.
    * Start the container named `webnc-mysql`.
    * Expose the database on your machine's port **3307**.
    * Create a database named `webnc_db`.
    * **Crucially**: It will automatically run the `sakila-mysql.sql` script to create and populate your tables.

4.  You can verify the database is running with `docker-compose ps`:

    ```
    NAME          COMMAND                  SERVICE       STATUS        PORTS
    webnc-mysql   "docker-entrypoint.s…"   webnc-mysql   running (healthy)   0.0.0.0:3307->3306/tcp
    ```

**Note:** The SQL initialization only runs the *first time* the container is created. If you need to re-run the initialization, you must first completely destroy the database and its data volume:

```bash
docker-compose down -v
```

Then run `docker-compose up -d` again.

### Step 4: Check Your Application Configuration

Your Spring Boot application is already configured to connect to this database. The file `src/main/resources/application.yml` should look like this:

```yaml
server:
  port: 8888  # The application will run on this port

spring:
  application:
    name: bt
  datasource:
    url: jdbc:mysql://localhost:3307/webnc_db # Connects to the Docker DB
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update # or 'none'
    show-sql: true
```

### Step 5: Run the Spring Boot Application

With the database running, you can now start the API server.

1.  In your terminal (in the same root directory), run the application using the Maven wrapper:

    ```bash
    # On macOS/Linux
    ./mvnw spring-boot:run

    # On Windows
    ./mvnw.cmd spring-boot:run
    ```

    *Alternatively, if you have Maven installed globally, you can just use `mvn spring-boot:run`.*

2.  Wait for the logs to show that the application has started. You should see a line similar to this:

    `INFO ... : Tomcat started on port 8888 (http) with context path '/'`

Your API is now running on `http://localhost:8888`.

-----

## API Endpoints (Testing with cURL)

You can now test your API. Open a **new terminal** (leave the server running in the other one) and use these `curl` commands.

*(Tip: Pipe the commands to `| jq` to get pretty-formatted JSON output).*

### 1\. View a list of all `actor`

* **Endpoint**: `GET /api/actors`

<!-- end list -->

```bash
curl -X GET http://localhost:8888/api/actors | jq
```

### 2\. View detail of an `actor`

* **Endpoint**: `GET /api/actors/{id}`
* *This example fetches the actor with ID 5.*

<!-- end list -->

```bash
curl -X GET http://localhost:8888/api/actors/5 | jq
```

### 3\. Add new `actor`

* **Endpoint**: `POST /api/actors`
* *This example adds a new actor "Tom Hanks".*

<!-- end list -->

```bash
curl -X POST http://localhost:8888/api/actors \
-H "Content-Type: application/json" \
-d '{
    "firstName": "TOM",
    "lastName": "HANKS"
}' | jq
```

*(You'll get a response with the new actor, including their `actorId` (e.g., 201)).*

### 4\. Update an `actor`

* **Endpoint**: `PUT /api/actors/{id}`
* *This example updates the actor with ID 5.*

<!-- end list -->

```bash
curl -X PUT http://localhost:8888/api/actors/5 \
-H "Content-Type: application/json" \
-d '{
    "firstName": "JOHNNY (UPDATED)",
    "lastName": "LOLLOBRIGIDA"
}' | jq
```

### 5\. Delete an `actor`

* **Endpoint**: `DELETE /api/actors/{id}`
* *This example deletes the actor with ID 201 (the "Tom Hanks" we just created).*

<!-- end list -->

```bash
curl -X DELETE http://localhost:8888/api/actors/201 | jq
```